'''

백트래킹은 dfs의 한 종류이다.

자연수 N,M이 주어졌을 때, 조건을 만족하는 길이가 M인 수열을
모두 구하는 프로그램 작성

-. 1부터 N까지 자연수 중에서 중복없이 M개를 고른 수열

N이 4, M이 2라면, 5까지 자연수 중에서 중복없이 2개를 고른 수열
4P2 = 4*3 = 12

출력은 아래와 같이 (4 2)

1 2
1 3
1 4
2 1
2 3
2 4
3 1
3 2
3 4
4 1
4 2
4 3

이걸 백트래킹이라고 부른다? 어떤 의미에서이지?
결국 Permutation 계산이다.

퍼뮤테이션의 모든 경우의 수를 찍어내는 것에 불과하다.

★★ 백트래킹에서 가장 중요한 것은,
가능한 모든 경우를 실행 --> 정답 ★★

모든 경우를 표현하는 가장 좋은 방법:
트리 형태로 펼쳐서 보는게 가장 좋다.

swea에 있는 백트래킹 시리즈도 풀이가 있다.

1. 첫 번쨰 숫자는 뭘로 할거냐?
n: 선택된 숫자의 갯수 (길이)
    * 길이 M짜리 수열을 만드는 것

N이라는 숫자를 넣어서 쭊 펼쳐서 만들어줄거다.
N은 일반화를 시켜서 N으로 지정해줘야 한다. 

중복 없이 골라야 하니까 중복 체크하는 방법은 다양하다
1. V[]
2. if 함수
3. 별도 함수 따로 제작

백트래킹의 재귀함수는 들어가면 종료조건에 따른 정답처리와
하부함수 호출. 이렇게만 되어있다.
종료일 떄는 정답처리를 해주면 된다.

'''

# import sys
# sys.stdin = open("C:\jocoding\백준\백트래킹\input\Backtracking 15649번 input.txt", "r")

def dfs(s, list):
    # 맨 위쪽에는 종료조건 처리 + 정답처리
    # 종료조건은 n에 관련된 형태로 잡아주는게 맞다
    # n을 발전시키다가 특정 경우가 되면 끝나게 해야된다. 
    
    if s == M: # M개의 수열을 완성
        print(*list)
        # ans.append(list)
        return

    # 하부단계(함수) 호출
    for j in range(1, N+1):
        # print(j)
        if v[j] == 0: # 선택하지 않은 숫자인 경우 추가
            v[j] = 1
            # print(v[j])
            dfs(s+1, list+[j])
            # print(list + [j])
            v[j] = 0


N,M = map(int, input().split())

ans = [] # 정답 리스트 저장할 리스트 

# 처음에 visited 배열은 무조건 0으로 초기화, 안간걸 
# 기준으로 생각하고 선언한다.
v = [0] * (N+1) # 중복확인을 위한 visited[] 배열

dfs(0, [])

# for list in ans:
#    print(*list)












