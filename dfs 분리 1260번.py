'''
1260 번

그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 
작성하시오. 단, 방문할 수 있는 "정점이 여러 개인 경우에는 정점 번호가 
작은 것을 먼저 방문"하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 
"정점 번호는 1번부터 N번까지"이다.

dfs만 분리.

예제 입력,
5 5 3 - 5개의 노드, 5개의 간선, 시작노드 3
5 4 - 5번 노드에 4번 노드 연결 
5 2 - 5번 노드에 2번 노드 연결
1 2 - 1번 노드에 2번 노드 연결
3 4 - 3번 노드에 4번 노드 연결
3 1 - 3번 노드에 1번 노드 연결

예제 출력:
3 1 2 5 4 - 순서대로 탐색


전체적으로 봤을 때, dfs가 bfs 보다는 쉬운 것 같다.

'''

## 함수 정의부 ============================================

## dfs 는 깊이 우선 탐색...
def dfs(c): # 출발 노드를 현재 current node로 받는다.
    ans_dfs.append(c) # c를 방문한 노드에 넣는다.
    arr[c] = 1 # c가 방문된 노드임을 표기하기 위해 1로 값을 준다.
    # 여기까지가 사전 전처리 작업 느낌.

    for n in adj[c]:
        if not arr[n]: # arr[n]의 값이 1이 아니라면,
            dfs(n)

## 입력부 =================================================

n, m, v = map(int, input().split())

adj = [[] for _ in range(n+1)]

for _ in range(m): # 간선의 갯수만큼
    head_edge, tail_edge = map(int, input().split())
    adj[head_edge].append(tail_edge)
    adj[tail_edge].append(head_edge)

for i in range(1, n+1):
    adj[i].sort() 


# 아래 두 개의 배열이 뭘 위한 배열인지 의미하는게 중요하다.
arr = [0] * (n+1) # 방문한 노드의 값을 1로 표현하기 위한 배열
ans_dfs = [] # 방문된 노드들을 담기 위한 배열, 그냥 순서 상관없이 가는 순서대로 담는다.
dfs(v) # 시작노드를 dfs 함수에 대입.

## 출력부 =================================================

# print(ans_dfs) # 배열 형식으로 출력
print(*ans_dfs) # 정수 리스트 형식으로 출력